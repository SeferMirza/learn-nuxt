import{q as j,g as W,s as b,v as X,x as S,y as I,z as q,A as F,B as J,C as Q,d as N,D as E,E as Y,G as Z,H as x,b as P,I as K,J as A,p as k,c as V,a as u,f as w,t as C,F as aa,r as ea,o as B}from"#entry";const ta={trailing:!0};function sa(a,e=25,i={}){if(i={...ta,...i},!Number.isFinite(e))throw new TypeError("Expected `wait` to be a finite number");let o,t,r=[],s,c;const f=(n,_)=>(s=na(a,n,_),s.finally(()=>{if(s=null,i.trailing&&c&&!t){const D=f(n,c);return c=null,D}}),s),m=function(...n){return i.trailing&&(c=n),s||new Promise(_=>{const D=!t&&i.leading;clearTimeout(t),t=setTimeout(()=>{t=null;const d=i.leading?o:f(this,n);c=null;for(const p of r)p(d);r=[]},e),D?(o=f(this,n),_(o)):r.push(_)})},l=n=>{n&&(clearTimeout(n),t=null)};return m.isPending=()=>!!t,m.cancel=()=>{l(t),r=[],c=null},m.flush=()=>{if(l(t),!c||s)return;const n=c;return c=null,f(this,n)},m}async function na(a,e,i){return await a.apply(e,i)}const ra=Symbol.for("nuxt:client-only"),ia=a=>a==="defer"||a===!1;function oa(...a){const e=typeof a[a.length-1]=="string"?a.pop():void 0;la(a[0],a[1])&&a.unshift(e);let[i,o,t={}]=a;const r=j(()=>Q(i));if(typeof r.value!="string")throw new TypeError("[nuxt] [useAsyncData] key must be a string.");if(typeof o!="function")throw new TypeError("[nuxt] [useAsyncData] handler must be a function.");const s=W();t.server??=!0,t.default??=ca,t.getCachedData??=M,t.lazy??=!1,t.immediate??=!0,t.deep??=b.deep,t.dedupe??="cancel",t._functionName,s._asyncData[r.value];const c={cause:"initial",dedupe:t.dedupe};s._asyncData[r.value]?._init||(c.cachedData=t.getCachedData(r.value,s,{cause:"initial"}),s._asyncData[r.value]=G(s,r.value,o,t,c.cachedData));const f=s._asyncData[r.value];f._deps++;const m=()=>s._asyncData[r.value].execute(c),l=t.server!==!1&&s.payload.serverRendered;{let D=function(v){const y=s._asyncData[v];y?._deps&&(y._deps--,y._deps===0&&y?._off())};const d=X();if(d&&l&&t.immediate&&!d.sp&&(d.sp=[]),d&&!d._nuxtOnBeforeMountCbs){d._nuxtOnBeforeMountCbs=[];const v=d._nuxtOnBeforeMountCbs;S(()=>{v.forEach(y=>{y()}),v.splice(0,v.length)}),I(()=>v.splice(0,v.length))}const p=d&&(d._nuxtClientOnly||q(ra,!1));l&&s.isHydrating&&(f.error.value||f.data.value!=null)?(f.pending.value=!1,f.status.value=f.error.value?"error":"success"):d&&(!p&&s.payload.serverRendered&&s.isHydrating||t.lazy)&&t.immediate?d._nuxtOnBeforeMountCbs.push(m):t.immediate&&m();const h=K(),g=F(r,(v,y)=>{if((v||y)&&v!==y){const z=s._asyncData[y]?.data.value!==b.value,U=s._asyncDataPromises[y]!==void 0;y&&D(y);const H={cause:"initial",dedupe:t.dedupe};if(!s._asyncData[v]?._init){let O;y&&z?O=s._asyncData[y]?.data.value:(O=t.getCachedData(v,s,{cause:"initial"}),H.cachedData=O),s._asyncData[v]=G(s,v,o,t,O)}s._asyncData[v]._deps++,(t.immediate||z||U)&&s._asyncData[v].execute(H)}},{flush:"sync"}),T=t.watch?F(t.watch,()=>{f._execute({cause:"watch",dedupe:t.dedupe})}):()=>{};h&&J(()=>{g(),T(),D(r.value)})}const n={data:R(()=>s._asyncData[r.value]?.data),pending:R(()=>s._asyncData[r.value]?.pending),status:R(()=>s._asyncData[r.value]?.status),error:R(()=>s._asyncData[r.value]?.error),refresh:(...D)=>s._asyncData[r.value].execute(...D),execute:(...D)=>s._asyncData[r.value].execute(...D),clear:()=>L(s,r.value)},_=Promise.resolve(s._asyncDataPromises[r.value]).then(()=>n);return Object.assign(_,n),_}function R(a){return j({get(){return a()?.value},set(e){const i=a();i&&(i.value=e)}})}function la(a,e){return!(typeof a=="string"||typeof a=="object"&&a!==null||typeof a=="function"&&typeof e=="function")}function L(a,e){e in a.payload.data&&(a.payload.data[e]=void 0),e in a.payload._errors&&(a.payload._errors[e]=b.errorValue),a._asyncData[e]&&(a._asyncData[e].data.value=void 0,a._asyncData[e].error.value=b.errorValue,a._asyncData[e].pending.value=!1,a._asyncData[e].status.value="idle"),e in a._asyncDataPromises&&(a._asyncDataPromises[e]&&(a._asyncDataPromises[e].cancelled=!0),a._asyncDataPromises[e]=void 0)}function ua(a,e){const i={};for(const o of e)i[o]=a[o];return i}function G(a,e,i,o,t){a.payload._errors[e]??=b.errorValue;const r=o.getCachedData!==M,s=i,c=o.deep?N:E,f=t!=null,m=a.hook("app:data:refresh",async n=>{(!n||n.includes(e))&&await l.execute({cause:"refresh:hook"})}),l={data:c(f?t:o.default()),pending:E(!f),error:Y(a.payload._errors,e),status:E("idle"),execute:(...n)=>{const[_,D=void 0]=n,d=_&&D===void 0&&typeof _=="object"?_:{};if(a._asyncDataPromises[e]){if(ia(d.dedupe??o.dedupe))return a._asyncDataPromises[e];a._asyncDataPromises[e].cancelled=!0}if(d.cause==="initial"||a.isHydrating){const h="cachedData"in d?d.cachedData:o.getCachedData(e,a,{cause:d.cause??"refresh:manual"});if(h!=null)return a.payload.data[e]=l.data.value=h,l.error.value=b.errorValue,l.status.value="success",Promise.resolve(h)}l.pending.value=!0,l.status.value="pending";const p=new Promise((h,g)=>{try{h(s(a))}catch(T){g(T)}}).then(async h=>{if(p.cancelled)return a._asyncDataPromises[e];let g=h;o.transform&&(g=await o.transform(h)),o.pick&&(g=ua(g,o.pick)),a.payload.data[e]=g,l.data.value=g,l.error.value=b.errorValue,l.status.value="success"}).catch(h=>{if(p.cancelled)return a._asyncDataPromises[e];l.error.value=x(h),l.data.value=P(o.default()),l.status.value="error"}).finally(()=>{p.cancelled||(l.pending.value=!1,delete a._asyncDataPromises[e])});return a._asyncDataPromises[e]=p,a._asyncDataPromises[e]},_execute:sa((...n)=>l.execute(...n),0,{leading:!0}),_default:o.default,_deps:0,_init:!0,_hash:void 0,_off:()=>{m(),a._asyncData[e]?._init&&(a._asyncData[e]._init=!1),r||Z(()=>{a._asyncData[e]?._init||(L(a,e),l.execute=()=>Promise.resolve(),l.data.value=b.value)})}};return l}const ca=()=>b.value,M=(a,e,i)=>{if(e.isHydrating)return e.payload.data[a];if(i.cause!=="refresh:manual"&&i.cause!=="refresh:hook")return e.static.data[a]};function da(){const{public:{gitHubBaseURL:a}}=A();async function e(t){return await $fetch(`repos/${t}/stats/contributors`,{baseURL:a,method:"GET",headers:{"X-GitHub-Api-Version":"2022-11-28"}})}async function i(t){return await $fetch(`repos/${t}`,{baseURL:a,method:"GET",headers:{"X-GitHub-Api-Version":"2022-11-28"}})}async function o(t){return await $fetch(`orgs/${t}`,{baseURL:a,method:"GET",headers:{"X-GitHub-Api-Version":"2022-11-28"}})}return{getContributorStats:e,getRepository:i,getOrganization:o}}const fa={class:"container"},_a={class:"organization"},va={class:"repository"},ya={class:"contributors"},ma={class:"contributor"},Da=["src"],$="mouseless",ga={__name:"fetching-data",async setup(a){let e,i;const{getContributorStats:o,getRepository:t,getOrganization:r}=da(),s=`${$}/learn-nuxt`,c=N([]),f=N(),{data:m}=([e,i]=k(async()=>oa("organization",async()=>await r($))),e=await e,i(),e);return S(async()=>c.value=await t(s)),S(async()=>f.value=await o(s)),(l,n)=>(B(),V("div",fa,[u("div",_a,[n[3]||(n[3]=u("h2",null,"Fetch Once - Server or Client",-1)),u("div",null,[n[0]||(n[0]=u("strong",null,"Organization:",-1)),w(" "+C(P(m).name)+" ",1),n[1]||(n[1]=u("br",null,null,-1)),n[2]||(n[2]=u("strong",null,"Public repositories count:",-1)),w(" "+C(P(m).public_repos),1)])]),u("div",va,[n[7]||(n[7]=u("h2",null,"Fetch Once - Only Client",-1)),u("div",null,[n[4]||(n[4]=u("strong",null,"Repository:",-1)),w(" "+C(P(c)?.name)+" ",1),n[5]||(n[5]=u("br",null,null,-1)),n[6]||(n[6]=u("strong",null,"Description:",-1)),w(" "+C(P(c)?.description),1)])]),u("div",null,[n[9]||(n[9]=u("h2",null,"Fetch Twice - Server and Client",-1)),u("div",ya,[(B(!0),V(aa,null,ea(P(f),_=>(B(),V("div",{key:_.author.login},[u("div",ma,[u("img",{class:"profile-image",src:_.author.avatar_url},null,8,Da),u("h3",null,C(_.author.login),1),u("p",null,[n[8]||(n[8]=u("strong",null,"Total commits:",-1)),w(" "+C(_.total),1)])])]))),128))])])]))}};export{ga as default};
