import{q as N,g as U,s as W,v as X,x as B,y as I,z as q,A as G,B as J,C as Q,d as S,D as H,E as Y,G as Z,H as x,b as p,I as K,J as A,p as k,c as T,a as u,f as P,t as C,F as aa,r as ea,o as E}from"#entry";const ta={trailing:!0};function sa(a,e=25,i={}){if(i={...ta,...i},!Number.isFinite(e))throw new TypeError("Expected `wait` to be a finite number");let o,t,r=[],s,l;const f=(n,v)=>(s=na(a,n,v),s.finally(()=>{if(s=null,i.trailing&&l&&!t){const D=f(n,l);return l=null,D}}),s),y=function(...n){return i.trailing&&(l=n),s||new Promise(v=>{const D=!t&&i.leading;clearTimeout(t),t=setTimeout(()=>{t=null;const d=i.leading?o:f(this,n);l=null;for(const b of r)b(d);r=[]},e),D?(o=f(this,n),v(o)):r.push(v)})},c=n=>{n&&(clearTimeout(n),t=null)};return y.isPending=()=>!!t,y.cancel=()=>{c(t),r=[],l=null},y.flush=()=>{if(c(t),!l||s)return;const n=l;return l=null,f(this,n)},y}async function na(a,e,i){return await a.apply(e,i)}const ra=Symbol.for("nuxt:client-only");function ia(...a){const e=typeof a[a.length-1]=="string"?a.pop():void 0;oa(a[0],a[1])&&a.unshift(e);let[i,o,t={}]=a;const r=N(()=>Q(i));if(typeof r.value!="string")throw new TypeError("[nuxt] [useAsyncData] key must be a string.");if(typeof o!="function")throw new TypeError("[nuxt] [useAsyncData] handler must be a function.");const s=U();t.server??=!0,t.default??=ua,t.getCachedData??=L,t.lazy??=!1,t.immediate??=!0,t.deep??=W.deep,t.dedupe??="cancel",t._functionName,s._asyncData[r.value];const l={cause:"initial",dedupe:t.dedupe};s._asyncData[r.value]?._init||(l.cachedData=t.getCachedData(r.value,s,{cause:"initial"}),s._asyncData[r.value]=V(s,r.value,o,t,l.cachedData));const f=s._asyncData[r.value];f._deps++;const y=()=>s._asyncData[r.value].execute(l),c=t.server!==!1&&s.payload.serverRendered;{let D=function(_){const m=s._asyncData[_];m?._deps&&(m._deps--,m._deps===0&&m?._off())};const d=X();if(d&&c&&t.immediate&&!d.sp&&(d.sp=[]),d&&!d._nuxtOnBeforeMountCbs){d._nuxtOnBeforeMountCbs=[];const _=d._nuxtOnBeforeMountCbs;B(()=>{_.forEach(m=>{m()}),_.splice(0,_.length)}),I(()=>_.splice(0,_.length))}const b=d&&(d._nuxtClientOnly||q(ra,!1));c&&s.isHydrating&&(f.error.value||f.data.value!==void 0)?f.status.value=f.error.value?"error":"success":d&&(!b&&s.payload.serverRendered&&s.isHydrating||t.lazy)&&t.immediate?d._nuxtOnBeforeMountCbs.push(y):t.immediate&&f.status.value!=="success"&&y();const h=K(),g=G(r,(_,m)=>{if((_||m)&&_!==m){const z=s._asyncData[m]?.data.value!==void 0,M=s._asyncDataPromises[m]!==void 0;m&&D(m);const F={cause:"initial",dedupe:t.dedupe};if(!s._asyncData[_]?._init){let w;m&&z?w=s._asyncData[m]?.data.value:(w=t.getCachedData(_,s,{cause:"initial"}),F.cachedData=w),s._asyncData[_]=V(s,_,o,t,w)}s._asyncData[_]._deps++,(t.immediate||z||M)&&s._asyncData[_].execute(F)}},{flush:"sync"}),R=t.watch?G(t.watch,()=>{f._execute({cause:"watch",dedupe:t.dedupe})}):()=>{};h&&J(()=>{g(),R(),D(r.value)})}const n={data:O(()=>s._asyncData[r.value]?.data),pending:O(()=>s._asyncData[r.value]?.pending),status:O(()=>s._asyncData[r.value]?.status),error:O(()=>s._asyncData[r.value]?.error),refresh:(...D)=>s._asyncData[r.value].execute(...D),execute:(...D)=>s._asyncData[r.value].execute(...D),clear:()=>j(s,r.value)},v=Promise.resolve(s._asyncDataPromises[r.value]).then(()=>n);return Object.assign(v,n),v}function O(a){return N({get(){return a()?.value},set(e){const i=a();i&&(i.value=e)}})}function oa(a,e){return!(typeof a=="string"||typeof a=="object"&&a!==null||typeof a=="function"&&typeof e=="function")}function j(a,e){e in a.payload.data&&(a.payload.data[e]=void 0),e in a.payload._errors&&(a.payload._errors[e]=void 0),a._asyncData[e]&&(a._asyncData[e].data.value=p(a._asyncData[e]._default()),a._asyncData[e].error.value=void 0,a._asyncData[e].status.value="idle"),e in a._asyncDataPromises&&(a._asyncDataPromises[e]&&(a._asyncDataPromises[e].cancelled=!0),a._asyncDataPromises[e]=void 0)}function ca(a,e){const i={};for(const o of e)i[o]=a[o];return i}function V(a,e,i,o,t){a.payload._errors[e]??=void 0;const r=o.getCachedData!==L,s=i,l=o.deep?S:H,f=t!==void 0,y=a.hook("app:data:refresh",async n=>{(!n||n.includes(e))&&await c.execute({cause:"refresh:hook"})}),c={data:l(f?t:o.default()),pending:N(()=>c.status.value==="pending"),error:Y(a.payload._errors,e),status:H("idle"),execute:(...n)=>{const[v,D=void 0]=n,d=v&&D===void 0&&typeof v=="object"?v:{};if(a._asyncDataPromises[e]){if((d.dedupe??o.dedupe)==="defer")return a._asyncDataPromises[e];a._asyncDataPromises[e].cancelled=!0}{const h="cachedData"in d?d.cachedData:o.getCachedData(e,a,{cause:d.cause??"refresh:manual"});if(h!==void 0)return a.payload.data[e]=c.data.value=h,c.error.value=void 0,c.status.value="success",Promise.resolve(h)}c.status.value="pending";const b=new Promise((h,g)=>{try{h(s(a))}catch(R){g(R)}}).then(async h=>{if(b.cancelled)return a._asyncDataPromises[e];let g=h;o.transform&&(g=await o.transform(h)),o.pick&&(g=ca(g,o.pick)),a.payload.data[e]=g,c.data.value=g,c.error.value=void 0,c.status.value="success"}).catch(h=>{if(b.cancelled)return a._asyncDataPromises[e];c.error.value=x(h),c.data.value=p(o.default()),c.status.value="error"}).finally(()=>{b.cancelled||delete a._asyncDataPromises[e]});return a._asyncDataPromises[e]=b,a._asyncDataPromises[e]},_execute:sa((...n)=>c.execute(...n),0,{leading:!0}),_default:o.default,_deps:0,_init:!0,_hash:void 0,_off:()=>{y(),a._asyncData[e]?._init&&(a._asyncData[e]._init=!1),r||Z(()=>{a._asyncData[e]?._init||(j(a,e),c.execute=()=>Promise.resolve())})}};return c}const ua=()=>{},L=(a,e,i)=>{if(e.isHydrating)return e.payload.data[a];if(i.cause!=="refresh:manual"&&i.cause!=="refresh:hook")return e.static.data[a]};function la(){const{public:{gitHubBaseURL:a}}=A();async function e(t){return await $fetch(`repos/${t}/stats/contributors`,{baseURL:a,method:"GET",headers:{"X-GitHub-Api-Version":"2022-11-28"}})}async function i(t){return await $fetch(`repos/${t}`,{baseURL:a,method:"GET",headers:{"X-GitHub-Api-Version":"2022-11-28"}})}async function o(t){return await $fetch(`orgs/${t}`,{baseURL:a,method:"GET",headers:{"X-GitHub-Api-Version":"2022-11-28"}})}return{getContributorStats:e,getRepository:i,getOrganization:o}}const da={class:"container"},fa={class:"organization"},va={class:"repository"},_a={class:"contributors"},ma={class:"contributor"},ya=["src"],$="mouseless",ha={__name:"fetching-data",async setup(a){let e,i;const{getContributorStats:o,getRepository:t,getOrganization:r}=la(),s=`${$}/learn-nuxt`,l=S([]),f=S(),{data:y}=([e,i]=k(async()=>ia("organization",async()=>await r($))),e=await e,i(),e);return B(async()=>l.value=await t(s)),B(async()=>f.value=await o(s)),(c,n)=>(E(),T("div",da,[u("div",fa,[n[3]||(n[3]=u("h2",null,"Fetch Once - Server or Client",-1)),u("div",null,[n[0]||(n[0]=u("strong",null,"Organization:",-1)),P(" "+C(p(y).name)+" ",1),n[1]||(n[1]=u("br",null,null,-1)),n[2]||(n[2]=u("strong",null,"Public repositories count:",-1)),P(" "+C(p(y).public_repos),1)])]),u("div",va,[n[7]||(n[7]=u("h2",null,"Fetch Once - Only Client",-1)),u("div",null,[n[4]||(n[4]=u("strong",null,"Repository:",-1)),P(" "+C(p(l)?.name)+" ",1),n[5]||(n[5]=u("br",null,null,-1)),n[6]||(n[6]=u("strong",null,"Description:",-1)),P(" "+C(p(l)?.description),1)])]),u("div",null,[n[9]||(n[9]=u("h2",null,"Fetch Twice - Server and Client",-1)),u("div",_a,[(E(!0),T(aa,null,ea(p(f),v=>(E(),T("div",{key:v.author.login},[u("div",ma,[u("img",{class:"profile-image",src:v.author.avatar_url},null,8,ya),u("h3",null,C(v.author.login),1),u("p",null,[n[8]||(n[8]=u("strong",null,"Total commits:",-1)),P(" "+C(v.total),1)])])]))),128))])])]))}};export{ha as default};
